
#' Synchronizes report project with config and python
#' dependencies set through options. Uses .report_dir_name_init.json
#' to track differences.
#'
#' @param project_dir The file path to the main project directory
#' where the directory structure will be created.
#' The directory must already exist; otherwise, an error will be thrown.
#' @param report_dir_name The directory name for where reports will be saved,
#' default NULL will use "report"
#'
#' @export
#'
#' @examples \dontrun{
#' sync_report_project(here::here())
#' }
sync_report_project <- function(project_dir, report_dir_name = NULL) {
  log4r::debug(.le$logger, "Starting sync_report_project function")

  # read in init.json files
  if (!is.null(report_dir_name)) {
    path_name <- sub("/", "_", report_dir_name)
  } else {
    path_name <- "report"
  }
  init_file <- file.path(project_dir, paste0(".", path_name, "_init.json"))
  log4r::debug(
    .le$logger,
    paste0("Using ", init_file, " as project initialization file.")
  )

  if (!file.exists(init_file)) {
    log4r::debug(.le$logger, paste0(init_file, " does not exist."))
    stop(
      paste(init_file, "file does not exist. "),
      "Are you sure you supplied the correct report_dir_name?"
    )
  }

  log4r::debug(.le$logger, paste0(init_file, "exists and being read now"))
  init <- jsonlite::read_json(init_file, simplifyVector = TRUE)
  # bool for later use
  update_init_file <- FALSE

  log4r::debug(
    .le$logger,
    "Grabbing python deps info from options and filesystem"
  )
  # Grab python dep info
  uv_path <- get_uv_path()
  args <- get_args(uv_path)
  pyvers <- get_py_version(getOption("venv_dir"))
  args <- c(args, pyvers)
  args_name <- c(
    "venv_dir",
    "python-docx.version",
    "pyyaml.version",
    "pillow.version",
    "uv.version",
    "python.version"
  )
  py_version_data <- stats::setNames(as.list(args), args_name)
  log4r::debug(
    .le$logger,
    paste0(
      "Obtained the following python deps: ",
      paste0(py_version_data, collapse = ",")
    )
  )

  # check init against current py dep requests
  if (!identical(init$python_versions, py_version_data)) {
    log4r::debug(.le$logger, "init file and py version deps out of sync.")
    message(
      paste0(
        "Python dependency versions have been changed, updating ",
        init_file
      )
    )
    log4r::debug(.le$logger, "Calling initialize_python now")
    initialize_python(continue = "Y")
    update_init_file <- TRUE
  }
  # Check config
  config <- yaml::read_yaml(
    file.path(project_dir, report_dir_name, "config.yaml"),
    handlers = list(logical = yaml::verbatim_logical)
  )

  if (!identical(config, init$config)) {
    message(
      paste0(
        "Configuration has changed, updating ",
        init_file
      )
    )
    if (config$report_dir_name != init$config$report_dir_name) {
      warning(
        paste0(
          "report_dir_name has been changed in config.yaml. \n",
          "  Please reconcile names\n",
          "\told: ",
          init$config$report_dir_name,
          "\n",
          "\tnew: ",
          config$report_dir_name
        )
      )
      config$report_dir_name <- init$config$report_dir_name
    }

    if (config$outputs_dir_name != init$config$outputs_dir_name) {
      warning(
        paste0(
          "outputs_dir_name has been changed in config.yaml. \n",
          "  Please reconcile names \n",
          "\told: ",
          init$config$outputs_dir_name,
          "\n",
          "\tnew: ",
          config$outputs_dir_name
        )
      )
      config$outputs_dir_name <- init$config$outputs_dir_name
    }
    update_init_file <- TRUE
  }

  if (update_init_file) {
    message("Updated")
    init$last_modified <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")
    init$user <- Sys.info()[["user"]]
    init$python_versions <- py_version_data
    init$config <- config

    json_data <- jsonlite::toJSON(init, pretty = TRUE, auto_unbox = TRUE)
    json_with_comment <- paste(
      "// WARNING: This file is automatically generated on initialization. Do not edit by hand!",
      json_data,
      sep = "\n"
    )
    write(json_with_comment, file = init_file)
  } else {
    message("Nothing to do")
  }
}
